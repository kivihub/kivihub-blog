## 一、链表

### 1、链表翻转

**方法**

递归后序遍历进行处理

**图示**

<img src="../../src/main/resources/picture/image-20220212153731529.png" alt="image-20220212153731529"  />

**题目**

- [奇升偶降链表排序](https://mp.weixin.qq.com/s/0WVa2wIAeG0nYnVndZiEXQ)
- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
- [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

### 2、链表合并

**方法**

空头节点、双指针、优先级队列

**题目**

- [奇升偶降链表排序](https://mp.weixin.qq.com/s/0WVa2wIAeG0nYnVndZiEXQ)

### 3、链表遍历

**方法**

空头节点、快慢指针

**题目**

* [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)
* [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)
* [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
* [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

## 二、字符串

### 1、字符匹配

**方法**

动态规划+备忘录

KMP

```java
public class KMP {
    private int[][] dp;
    private String pat;
  
    public KMP(String pat) {
        this.pat = pat;
        int M = pat.length();
        // dp[状态][字符] = 下个状态
        dp = new int[M][256];
        // base case
        dp[0][pat.charAt(0)] = 1;
        // 影子状态 X 初始为 0
        int X = 0;
        // 当前状态 j 从 1 开始
        for (int j = 1; j < M; j++) {
            for (int c = 0; c < 256; c++) {
                if (pat.charAt(j) == c) 
                    dp[j][c] = j + 1;
                else 
                    dp[j][c] = dp[X][c];
            }
            // 更新影子状态
            X = dp[X][pat.charAt(j)];
        }
    }

    public int search(String txt) {...}
}
```



**题目**

- [10.正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)
- [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

### 2、最长公共子序列

**方法**

动态规划

**题目**

- [1143.最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

## 三、数组

### 1、单调函数二分查找

二分查找法

```java
// 单调递减函数上，搜索左侧值
while (left <= right) {
    int mid = left + (right - left) / 2;
    int midVal = func(mid);
    if (midVal > target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
}
return left;
```

**题目**

- [1011.D天内运送包裹能力-隐式二分查找](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)
- [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

### 2、二维数组排序

**题目**

- [1024.视频拼接 - 首升尾降](https://leetcode-cn.com/problems/video-stitching/)
- [1288. 删除被覆盖区间 - 首升尾降](https://leetcode-cn.com/problems/remove-covered-intervals/)

### 3、差分数组

**题目**

- [1109.航班预定统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)

### 4、用Map降低时间复杂度

**题目**

* [28. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

### 5、二维数组深度遍历/回溯

**题目**

* [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

### 6、差分数组

转为相对落差图

**题目**

* [134. 加油站](https://leetcode-cn.com/problems/gas-station/)
* [253. 会议室 II - 计算重叠](https://leetcode-cn.com/problems/meeting-rooms-ii/)

### 7、双指针

**题目**

* [18. 四数之和](https://leetcode-cn.com/problems/4sum/)
* [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
* [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
* [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)
* [283. 移动零 — 可看作删除零 + 补零](https://leetcode-cn.com/problems/move-zeroes/)
* [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

### 8、单调队列

**题目**

* [239. 滑动窗口最大值 - 也可用优先级队列+RemoveMap](https://leetcode-cn.com/problems/sliding-window-maximum/)

## 四、二叉树

### 1、层级遍历

**方法**

借助双端队列

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if (root == null) {
      return new ArrayList<>();
    }
    Deque<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);
  
    List<List<Integer>> ret = new ArrayList<>();
    while (!queue.isEmpty()) {
      int size = queue.size();
      List<Integer> item = new ArrayList<>();
      ret.add(item);
      for (int i = 0; i < size; i++) {
        TreeNode node = queue.removeFirst();
        item.add(node.val);
        if (node.left != null) {
          queue.add(node.left);
        }
        if (node.right != null) {
          queue.add(node.right);
        }
      }
    }
    return  ret;
}
```

**题目**

- [102.二叉树层级遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

### 2、先序/中序/后序遍历

**题目**

- [105.从先序和中序遍历序列构造二叉序](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
- [112.路径总和](https://leetcode-cn.com/problems/path-sum/)
- [113.路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)
- [124.二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
- [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
- [1373. 二叉搜索子树的最大键值和](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/)
- [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
- [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

### 3、二叉搜索树

**题目**

* [240. 搜索二维矩阵 II - 右上角为根的二叉搜索树](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

## 五、贪心

**题目**

* [11.盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

## 六、动态规划

**方法**

状态转移方程 + 状态压缩（可选）+ 正确遍历方向

**题目**

* [121.买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
* [122.买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
* [123.买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
* [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
* [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
* [1312. 让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)
* [152. 乘积最大子数组 - 难点转移方程](https://leetcode-cn.com/problems/maximum-product-subarray/)
* [213. 打家劫舍 II - 环形](https://leetcode-cn.com/problems/house-robber-ii/)
* [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
* [312. 戳气球 - 转移方程 + 遍历方向](https://leetcode-cn.com/problems/burst-balloons/)

## 七、数据结构设计

**题目**

* [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)
* [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)
* [170. 两数之和 III - 数据结构设计](https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/)
* [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)
* [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)
* [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)

## 八、算法

### 1、DIJKSTRA

**题目**

* [1514. 概率最大的路径](https://leetcode-cn.com/problems/path-with-maximum-probability/)
* [1631. 最小体力消耗路径 - DFS可以AC](https://leetcode-cn.com/problems/path-with-minimum-effort/)

### 2、拓扑排序

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] inbouds = new int[numCourses];
        List<Integer>[] srcTargetList = new List[numCourses];
        for (int i = 0; i < numCourses; i++) {
            srcTargetList[i] = new ArrayList<>();
        }
        for (int[] pre : prerequisites) {
            inbouds[pre[0]]++;
            srcTargetList[pre[1]].add(pre[0]);
        }

        Queue<Integer> zeroInbounds = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inbouds[i] == 0) {
                zeroInbounds.offer(i);
            }
        }

        int[] ret = new int[numCourses];
        int count = 0;
        while (!zeroInbounds.isEmpty()) {
            int cur = zeroInbounds.poll();
            ret[count++] = cur;
            for (int target : srcTargetList[cur]) {
                inbouds[target]--;
                if (inbouds[target] == 0) {
                    zeroInbounds.offer(target);
                }
            }
        }
        if (count == numCourses) {
            return ret;
        } else {
            return new int[]{};
        }
    }
}
```

**题目**

* [207. 课程表 - 拓扑 or DFS](https://leetcode-cn.com/problems/course-schedule/)
* [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)
* [23. 拓扑](https://mp.weixin.qq.com/s/pCRscwKqQdYYN7M1Sia7xA)

### 3、分治

**题目**

* [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)

## 九、数学

**题目**

* [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)
* [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)
* [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)
* [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)
* [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)
* [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)
* [31. 下一个排列—尾部降序子序列，找到大于之前的元素进行交换，然后降序序列两两交换变为升序](https://leetcode-cn.com/problems/next-permutation/)

## 十、博弈

**题目**

* [292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/)

