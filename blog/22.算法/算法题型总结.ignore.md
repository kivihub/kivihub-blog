## 一、链表常见题

### 1、链表翻转

**方法**

递归后序遍历进行处理

**图示**

<img src="../../src/main/resources/picture/image-20220212153731529.png" alt="image-20220212153731529"  />

**题目**

- [奇升偶降链表排序](https://mp.weixin.qq.com/s/0WVa2wIAeG0nYnVndZiEXQ)
- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
- [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

### 2、链表合并

**方法**

空头节点、双指针、优先级队列

**题目**

- [奇升偶降链表排序](https://mp.weixin.qq.com/s/0WVa2wIAeG0nYnVndZiEXQ)

### 3、链表遍历

**方法**

空头节点、快慢指针

**题目**

* [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)
* [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)
* [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
* [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

## 二、字符串常见题

### 1、字符匹配

**方法**

动态规划+备忘录

KMP

```java
public class KMP {
    private int[][] dp;
    private String pat;
  
    public KMP(String pat) {
        this.pat = pat;
        int M = pat.length();
        // dp[状态][字符] = 下个状态
        dp = new int[M][256];
        // base case
        dp[0][pat.charAt(0)] = 1;
        // 影子状态 X 初始为 0
        int X = 0;
        // 当前状态 j 从 1 开始
        for (int j = 1; j < M; j++) {
            for (int c = 0; c < 256; c++) {
                if (pat.charAt(j) == c) 
                    dp[j][c] = j + 1;
                else 
                    dp[j][c] = dp[X][c];
            }
            // 更新影子状态
            X = dp[X][pat.charAt(j)];
        }
    }

    public int search(String txt) {...}
}
```



**题目**

- [10.正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)
- [28. 实现 strStr() - KMP](https://leetcode-cn.com/problems/implement-strstr/)

### 2、公共子序列

**方法**

动态规划，二分法

**题目**

- [1143.最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)
- [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)
- 最长递增子序列
    - [354. 俄罗斯套娃信封问题 - 首升尾降 转为求尾单调递增子序列](https://leetcode-cn.com/problems/russian-doll-envelopes/)


### 3、括号问题

**方法**

借助栈

```java
Stack<Integer> stk = new Stack<>();
for (int i = 0; i < s.length(); i++) {
    if (s.charAt(i) == '(') {
        // 遇到左括号，记录索引
        stk.push(i);
    } else {
        // 遇到右括号
        if (!stk.isEmpty()) {
            // 配对的左括号对应索引，[leftIndex, i] 是一个合法括号子串
            int leftIndex = stk.pop();
            // 这个合法括号子串的长度
            int len = 1 + i - leftIndex;
        } else {
            // 没有配对的左括号
        }
    }
}
```

**题目**

* [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)
* [1541. 平衡括号字符串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string/)
* [32. 最长有效括号 - 使用dp数组](https://leetcode-cn.com/problems/longest-valid-parentheses/)

### 4、回文

**方法**

递推，从中间向两侧扩展

**题目**

* [5. 最长回文子串 - 递推 or 从中间向两边扩展](https://leetcode-cn.com/problems/longest-palindromic-substring/)

## 三、数组/字符串通用解法

### 1、单调函数二分查找

二分查找法

```java
// 单调递减函数上，搜索左侧值
while (left <= right) {
    int mid = left + (right - left) / 2;
    int midVal = func(mid);
    if (midVal > target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
}
return left;
```

**题目**

- [1011.D天内运送包裹能力-隐式二分查找](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)
- [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)
- [33. 搜索旋转排序数组-判断在哪个递增区间](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
- [4. 寻找两个正序数组的中位数 - 两个数组](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)
- [410. 分割数组的最大值 - 难于发现隐示二分查找](https://leetcode-cn.com/problems/split-array-largest-sum/)

### 2、二维数组排序

首尾两个元素进行排序，第一个元素排序基于问题解决方案，第二个排序用于简化编程（只处理当前元素，不会处理之前扫描过的元素）

**题目**

- [1024.视频拼接 - 首升尾降](https://leetcode-cn.com/problems/video-stitching/)
- [1288. 删除被覆盖区间 - 首升尾降](https://leetcode-cn.com/problems/remove-covered-intervals/)
- [435. 无重叠区间 - 尾升首降](https://leetcode-cn.com/problems/non-overlapping-intervals/)
- [452. 用最少数量的箭引爆气球 - 尾升即可](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)
- [354. 俄罗斯套娃信封问题 - 首升尾降 转为求尾单调递增子序列](https://leetcode-cn.com/problems/russian-doll-envelopes/)
    - 普通解法容易超时


### 3、差分数组

**题目**

- [1109.航班预定统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)

### 4、用Map降低时间复杂度

**题目**

* [28. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

### 5、回溯/深度遍历

**题目**

* [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)
* [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)
* [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)
* [46. 全排列](https://leetcode-cn.com/problems/permutations/)

### 6、二维数组对角线遍历

通过row+col的和判断是处于向上/向下，来计算下个坐标。

**题目**

* [498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)

### 7、差分数组

转为相对落差图

**题目**

* [134. 加油站](https://leetcode-cn.com/problems/gas-station/)
* [253. 会议室 II - 计算重叠](https://leetcode-cn.com/problems/meeting-rooms-ii/)

### 8、双指针

**题目**

* [18. 四数之和](https://leetcode-cn.com/problems/4sum/)
* [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
* [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
* [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)
* [283. 移动零 — 可看作删除零 + 补零](https://leetcode-cn.com/problems/move-zeroes/)
* [3. 无重复字符的最长子串 - 窗口](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
* [340. 至多包含 K 个不同字符的最长子串 - 窗口](https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/)
* [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)
* [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

### 9、单调队列

**题目**

* [239. 滑动窗口最大值 - 也可用优先级队列+RemoveMap](https://leetcode-cn.com/problems/sliding-window-maximum/)

### 10、单调栈

**题目**

* [42. 接雨水 - 也可以直接找出最大，分两侧计算](https://leetcode-cn.com/problems/trapping-rain-water/)
* [496. 下一个更大元素 I - 从后往前构建单调栈](https://leetcode-cn.com/problems/next-greater-element-i/)
* [503. 下一个更大元素 II - 循环查找时，把数组扩为2倍](https://leetcode-cn.com/problems/next-greater-element-ii/)

### 11、负数代表下标存在

用元素的正负，替代Map来标识元素是否存在

**题目**

* [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)
* [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

## 四、二叉树

### 1、层级遍历

**方法**

借助双端队列

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if (root == null) {
      return new ArrayList<>();
    }
    Deque<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);
  
    List<List<Integer>> ret = new ArrayList<>();
    while (!queue.isEmpty()) {
      int size = queue.size();
      List<Integer> item = new ArrayList<>();
      ret.add(item);
      for (int i = 0; i < size; i++) {
        TreeNode node = queue.removeFirst();
        item.add(node.val);
        if (node.left != null) {
          queue.add(node.left);
        }
        if (node.right != null) {
          queue.add(node.right);
        }
      }
    }
    return  ret;
}
```

**题目**

- [102.二叉树层级遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

### 2、先序/中序/后序遍历

**题目**

- [105.从先序和中序遍历序列构造二叉序](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
- [112.路径总和](https://leetcode-cn.com/problems/path-sum/)
- [113.路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)
- [124.二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
- [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
- [1373. 二叉搜索子树的最大键值和](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/)
- [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
- [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

### 3、二叉搜索树

**题目**

* [240. 搜索二维矩阵 II - 右上角为根的二叉搜索树](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

## 六、动态规划

**方法**

状态转移方程 + 状态压缩（可选）+ 正确遍历方向

### 01背包

**题目**

* [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/) 

### 其他

**题目**

* [121.买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
* [122.买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
* [123.买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
* [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
* [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
* [1312. 让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)
* [152. 乘积最大子数组 - 难点转移方程](https://leetcode-cn.com/problems/maximum-product-subarray/)
* [213. 打家劫舍 II - 环形](https://leetcode-cn.com/problems/house-robber-ii/)
* [337. 打家劫舍 III - 树形](https://leetcode-cn.com/problems/house-robber-iii/)
* [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
* [312. 戳气球 - 转移方程 + 遍历方向](https://leetcode-cn.com/problems/burst-balloons/)
* [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
* [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)
* [354. 俄罗斯套娃信封问题 - 也可用二分法](https://leetcode-cn.com/problems/russian-doll-envelopes/)

## 七、数据结构设计

**题目**

* [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)
* [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)
* [170. 两数之和 III - 数据结构设计](https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/)
* [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)
* [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)
* [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)
* [341. 扁平化嵌套列表迭代器 - 惰性展开](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)
* [355. 设计推特](https://leetcode-cn.com/problems/design-twitter/)
* [460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)

## 八、算法

### 1、DIJKSTRA

**题目**

* [1514. 概率最大的路径](https://leetcode-cn.com/problems/path-with-maximum-probability/)
* [1631. 最小体力消耗路径 - DFS可以AC](https://leetcode-cn.com/problems/path-with-minimum-effort/)

### 2、拓扑排序

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] inbouds = new int[numCourses];
        List<Integer>[] srcTargetList = new List[numCourses];
        for (int i = 0; i < numCourses; i++) {
            srcTargetList[i] = new ArrayList<>();
        }
        for (int[] pre : prerequisites) {
            inbouds[pre[0]]++;
            srcTargetList[pre[1]].add(pre[0]);
        }

        Queue<Integer> zeroInbounds = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inbouds[i] == 0) {
                zeroInbounds.offer(i);
            }
        }

        int[] ret = new int[numCourses];
        int count = 0;
        while (!zeroInbounds.isEmpty()) {
            int cur = zeroInbounds.poll();
            ret[count++] = cur;
            for (int target : srcTargetList[cur]) {
                inbouds[target]--;
                if (inbouds[target] == 0) {
                    zeroInbounds.offer(target);
                }
            }
        }
        if (count == numCourses) {
            return ret;
        } else {
            return new int[]{};
        }
    }
}
```

**题目**

* [207. 课程表 - 拓扑 or DFS](https://leetcode-cn.com/problems/course-schedule/)
* [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)
* [23. 拓扑](https://mp.weixin.qq.com/s/pCRscwKqQdYYN7M1Sia7xA)

### 3、分治

**题目**

* [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)

### 4、并查集

计算连通性-[参考](https://labuladong.gitee.io/algo/2/19/38/)

```java
class UF {
    // 记录连通分量
    private int count;
    // 节点 x 的节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        // 将两棵树合并为一棵
        parent[rootP] = rootQ;
        // parent[rootQ] = rootP 也一样
        count--; // 两个分量合二为一
    }

    /* 返回某个节点 x 的根节点 */
    private int find(int x) {
        // 根节点的 parent[x] == x
        while (parent[x] != x)
            x = parent[x];
        return x;
    }

    /* 返回当前的连通分量个数 */
    public int count() { 
        return count;
    }
}
```

优化版：

```java
class UF {
    // 连通分量个数
    private int count;
    // 存储一棵树
    private int[] parent;
    // 记录树的「重量」
    private int[] size;

    // n 为图中节点的个数
    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    // 将节点 p 和节点 q 连通
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        
        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        // 两个连通分量合并成一个连通分量
        count--;
    }

    // 判断节点 p 和节点 q 是否连通
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    // 返回节点 x 的连通分量根节点
    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    // 返回图中的连通分量个数
    public int count() {
        return count;
    }
}
```

**题目**

* [323. 无向图中连通分量的数目](https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/)

### 5、贪心

**题目**

* [11.盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
* [45. 跳跃游戏 II - 更新每一跳最远位置](https://leetcode-cn.com/problems/jump-game-ii/)

## 九、数学

**题目**

* [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)
* [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)
* [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)
* [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)
* [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)
* [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)
* [372. 超级次方 - 平方的递推方程a^123 = a^3 * (a^12)^10](https://leetcode-cn.com/problems/super-pow/)
* [48. 旋转图像 - 用两次翻转代替旋转](https://leetcode-cn.com/problems/rotate-image/)
* 随机数
    * [380. O(1) 时间插入、删除和获取随机元素 - 数组 + Map + Rand函数](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)
    * [382. 链表随机节点 - 遍历链表，每个元素选中概率为1/n](https://leetcode-cn.com/problems/linked-list-random-node/)
    * [398. 随机数索引 - 同382](https://leetcode-cn.com/problems/random-pick-index/)
    * [470. 用 Rand7() 实现 Rand10() - 可通过1/2和1/5凑](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

* 字典序 - 力求局部递增/递减 or 多叉树计算前缀根的节点数
    * [31. 下一个排列—尾部降序子序列，找到大于之前的元素进行交换，然后降序序列两两交换变为升序](https://leetcode-cn.com/problems/next-permutation/)
    * [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)
    * [402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)
    * [440. 字典序的第K小数字 - 10叉树，难点求前缀根的节点数](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)


## 十、脑筋急转弯

**题目**

* [292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/)
* [319. 灯泡开关 - 平方根](https://leetcode-cn.com/problems/bulb-switcher/)
* [391. 完美矩形 - 三重判断：面积 + 顶点数 + 奇数点为最终顶点](https://leetcode-cn.com/problems/perfect-rectangle/)

