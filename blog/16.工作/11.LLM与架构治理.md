### 一、LLM重塑架构治理项的权重

随着cursor、trae等LLM IDE被程序员广泛使用，LLM承担了程序员的编程成本，而架构治理中目标为降低研发成本的治理项可能变得不再重要和必要。例如函数的认知复杂度，LLM能理解远超人类的上下文，可以快速理解函数的含义，甚至可以完成简单的需求开发。这时如果忽略LLM带来的变化，不调整治理项权重，那么必然会导致资源错位，沉没更多的机会成本。

除了对已有的治理项需要调低治理权重。LLM的应用可能会带来新的问题，这类问题可抽象的定义为基于模式生成代码的可用性问题。例如在使用LLM进行已有代码重构时出现的一些列badcase，见下表。这些问题随着LLM的应用，问题出现频次会在数量规模上放大，变成一个棘手的大问题。

| LLM重构复杂函数的BadCase | 详情                                                       | 严重等级  |
|:----------------- | -------------------------------------------------------- | ----- |
| 语法错误              | - 子方法入参类型推断错误<br/> - 删除已有函数，致其他go文件语法异常<br/> - 重复定义已有函数  | Fatal |
| 语义不一致             | - 控制逻辑不一致<br/>  - 丢失打点/日志代码<br/>  - 线程组使用有差异，致使并行度有差异    | Fatal |
| 引入异常代码            | - 新定义map，使用时未初始化<br/>  - 新增并发修改变量bug<br/>  - 修改/清空其他函数   | Fatal |
| 子函数风格             | - 重构不简约<br/>  - 过度抽象<br/>  - 常量替换为字符串<br/>  - 返回值存在冗余err | Warn  |

那么，架构治理项必然要随着LLM的应用而调整权重。其中一个调整思路为：由降低研发负担转目标变为提高LLM准确性和可用性的目标。

### 二、LLM重塑架构治理的思路

case 1：复杂函数治理，LLM think + LSP action思路。

1. [An Empirical Study on the Potential of LLMs in Automated Software Refactoring](https://arxiv.org/pdf/2411.04444)
2. [Refactoring vs Refuctoring: Advancing the state of AI- automated code improvements](https://codescene.com/hubfs/whitepapers/Refactoring-vs-Refuctoring-Advancing-the-state-of-AI-automated-code-improvements.pdf)
3. https://docs.vibe-coding-framework.com/refactoring-tools



case 2:服务耦合治理/强弱依赖/重复调用，使用LLM分析下钻代码。
