## 共享变量
### 一、PublicVar
通过PublicVar实现共享，有两种方式：

1）修改代码，每次升级时修改对应变量值

2）无需修改代码，通过ldflags在编译时指定变量值
#### ldflags使用示例
```go
// main.go
package main

import "fmt"

var Version = ""

func main() {
	fmt.Println("Version", Version)
	// ...
}
```

`go build -ldflags "-X main.Version=1.0.0" -x -o product main.go`
#### 共享变量
使用PublicVar当作共享变量时：
* 使用方必须引入共享变量所在module
* 存在**循环依赖风险**
 
要解决此类问题，推荐建立单独环境module，禁止outgoing依赖，避免循环依赖风险。
### 二、运行时传参/flag
执行go程序编译后的二进制产物时，增加参数。若当前编译出的二进制产物为go-product。
```shell
go-prudct -psm a.b.c -conf-dir conf
```

```go
package main

import (
	"flag"
	"fmt"
)

var psm string
var confDir string

func main() {
	// 相同的Flag name只能解析一次
	flag.StringVar(&psm, "psm", "default", "PSM")
	flag.StringVar(&confDir, "conf-dir", "default", "config directory")
	if !flag.Parsed() {
		flag.Parse()
	}
	fmt.Println("psm", psm)
	fmt.Println("confDir", confDir)
	f1()
}

func f1() {
    fmt.Println("flag.Lookup psm", flag.Lookup("psm").Value)
}
```
#### 共享变量
* flag.Parse方法调用前，`所定义的flag` 必须不少于 `实际的flag`，否则解析会异常
* flag.Parse方法调用后，不允许再次定义flag，解析前先判断`flag.Parsed()`

如果使用flag作为共享变量：
* 使用方无需引入多余module
* 由于执行顺序无法保证，所以使用方必须都有以下逻辑
    * 判断flag是否已解析过
    * 若未解析过，则定义所有flag，然后进行解析
    * 如果解析过，则通过flag.Lookup查找指定变量

### 三、os environment
设置操作系统环境变量，go通过`os.Getenv()`获取。

#### 共享变量
如果使用系统环境变量作为共享变量：
* 使用方无需引入多余module
* 获取逻辑简单
* 不适合于操作系统内运行多个差异化实例场景